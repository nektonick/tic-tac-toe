#include "input_output.h"
#include <QInputDialog>
#include <QMessageBox>
#include <QPushButton>
#include "field.h"
#include "player.h"
#include "ui_mainwindow.h" // autogenerated by QT


GUI_InputOutput::GUI_InputOutput()
    : QMainWindow(nullptr)
    , ui(new Ui::MainWindow())
    , scrollArea(new QScrollArea(this))
    , fieldWidget(new QWidget)
{
    ui->setupUi(this);
    setCentralWidget(scrollArea);
    show();
}

GUI_InputOutput::~GUI_InputOutput()
{
    delete ui;
}

FieldSize GUI_InputOutput::readFieldSize()
{
    QString windowTitle = "Input field size";
    QString inputTitle = "Field size(N*N):";
    int defaultValue = 3;
    int minValue = 1;
    int maxValue = 1000;
    int step = 1;
    bool ok = false;

    int size = defaultValue;
    while(!ok) {
        size = QInputDialog::getInt(this, windowTitle,
                                    inputTitle, defaultValue, minValue, maxValue, step, &ok);
    }
    return {size, size};
}

void GUI_InputOutput::initField(std::shared_ptr<Field> field)
{
    auto size = field->getFieldSize();
    gridLayout = new QGridLayout();
    for(uint32_t row = 0; row < size.getRowsCount(); ++row) {
        for(uint32_t column = 0; column < size.getColumnsCount(); ++column) {
            auto button = new QPushButton("");
            auto handleClick = [this, row, column] {
                auto button = qobject_cast<QPushButton*>(sender());
                if(!button->text().isEmpty()) {
                    showMessage("Field already marked! Select another field");
                } else {
                    userInput_ = {row, column};
                    inputLoop.quit();
                }
            };
            connect(button, &QPushButton::released, this, handleClick);
            gridLayout->addWidget(button, row, column);
        }
    }

    fieldWidget->setLayout(gridLayout);
    scrollArea->setWidget(fieldWidget);
}

void GUI_InputOutput::updateField(std::shared_ptr<Field> field)
{
    auto size = field->getFieldSize();
    for(uint32_t row = 0; row < size.getRowsCount(); ++row) {
        for(uint32_t column = 0; column < size.getColumnsCount(); ++column) {
            auto button = qobject_cast<QPushButton*>(gridLayout->itemAtPosition(row, column)->widget());
            QString newText = "";
            auto cellstate = field->getCellMark({row, column});
            if(cellstate.has_value()) {
                newText = cellstate.value() == MarkType::x ? "X" : "O";
            }
            button->setText(newText);
        }
    }
}

PlayerType GUI_InputOutput::getPlayerType(std::string_view msg)
{
    QString windowTitle = "Input player type";
    std::string inputTitleData = msg.data() + std::string(" (0 - AI, 1 - human):");
    QString inputTitle = inputTitleData.data();
    int defaultValue = 0;
    int minValue = 0;
    int maxValue = 1;
    int step = 1;
    bool ok = false;

    int type = defaultValue;
    while(!ok) {
        type = QInputDialog::getInt(this, windowTitle,
                                    inputTitle, defaultValue, minValue, maxValue, step, &ok);
    }

    return type == 0 ? PlayerType::AI : PlayerType::human;
}

uint32_t GUI_InputOutput::getCellsInRowToWinCount(uint32_t maxValue)
{
    QString windowTitle = "Input cells to win count";
    QString inputTitle = "Cells in row to win:";
    uint32_t defaultValue = 3;
    uint32_t minValue = 2;
    uint32_t step = 1;
    bool ok = false;

    uint32_t cellsCount = defaultValue;
    while(!ok) {
        cellsCount = QInputDialog::getInt(this, windowTitle,
                                          inputTitle, defaultValue, minValue, maxValue, step, &ok);
    }

    return cellsCount;
}

CellPosition GUI_InputOutput::readPlayerInput()
{
    userInput_ = std::nullopt;
    inputLoop.exec();
    return userInput_.value();
}

void GUI_InputOutput::showMessage(std::string_view msg)
{
    QMessageBox msgBox;
    msgBox.setText(msg.data());
    msgBox.exec();
}
